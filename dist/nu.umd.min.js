(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global.nu = factory());
}(this, (function () { 'use strict';

  const spreadArg = (fn) => (...args) => fn(args);

  const def = (x) => typeof x !== 'undefined';

  const reduce = ([ x, ...xs ], f, memo, i = 0) => (def(x) ? reduce(xs, f, f(memo, x, i), i + 1) : memo);

  const add = spreadArg(([ x, ...xs ]) => reduce(xs, (memo, y) => memo + y, x));

  const flow = (...args) => (init) => reduce(args, (memo, fn) => fn(memo), init);

  const reverse = (xs) => reduce(xs, (memo, x) => [ x, ...memo ], []);

  const compose = (...args) => flow(...reverse(args));

  const copy = (array) => [ ...array ];

  const divide = spreadArg(([ x, ...xs ]) => reduce(xs, (memo, y) => memo / y, x));

  const factorial = (x, acum = 1) => (x ? factorial(x - 1, x * acum) : acum);

  const fib = (x) => (x > 2 ? fib(x - 1) + fib(x - 2) : 1);

  const filter = (xs, fn) => reduce(xs, (memo, x) => (fn(x) ? [ ...memo, x ] : [ ...memo ]), []);

  const first = (xs, n) => reduce(xs, (memo, x, i) => (i < n ? [ ...memo, x ] : [ ...memo ]), []);

  const isArray = (x) => Array.isArray(x);

  const flatten = (xs) =>
    reduce(xs, (memo, x) => (x ? (isArray(x) ? [ ...memo, ...flatten(x) ] : [ ...memo, x ]) : []), []);

  const head = ([ x ]) => x;

  const length = (xs) => reduce(xs, (memo, x) => memo + 1, 0);

  const last = (xs, n) => reduce(xs, (memo, x, i) => (i >= length(xs) - n ? [ ...memo, x ] : [ ...memo ]), []);

  const map = (xs, fn) => reduce(xs, (memo, x) => [ ...memo, fn(x) ], []);

  const max = ([ x, ...xs ], result = -Infinity) => (def(x) ? (x > result ? max(xs, x) : max(xs, result)) : result);

  const merge = spreadArg((xs) => reduce(xs, (memo, x) => [ ...memo, ...x ], []));

  const min = ([ x, ...xs ], result = Infinity) => (def(x) ? (x < result ? min(xs, x) : result) : result);

  const multiply = spreadArg(([ x, ...xs ]) => reduce(xs, (memo, y) => memo * y, x));

  const partial = (fn, ...args) => (...newArgs) => fn(...args, ...newArgs);

  const pluck = (key, object) => object[key];

  const tail = ([ , ...xs ]) => xs;

  /* eslint-disable indent */

  const quicksort = (xs) =>
    length(xs)
      ? flatten([
          quicksort(filter(tail(xs), (x) => x <= head(xs))),
          head(xs),
          quicksort(filter(tail(xs), (x) => x > head(xs)))
        ])
      : [];

  const reduceRight = (xs, fn, memo) => reduce(reverse(xs), fn, memo);

  const reject = (xs, fn) => reduce(xs, (memo, x) => (fn(x) ? [ ...memo ] : [ ...memo, x ]), []);

  const reverseArgs = (fn) => (...args) => fn(...reverse(args));

  const slice = ([ x, ...xs ], i, y, curr = 0) =>
    def(x) ? (curr === i ? [ y, x, ...slice(xs, i, y, curr + 1) ] : [ x, ...slice(xs, i, y, curr + 1) ]) : [];

  const swap = (a, i, j) =>
    map(a, (x, y) => {
      if (y === i) return a[j]
      if (y === j) return a[i]
      return x
    });

  const undef = (x) => !def(x);

  var core = {
    add,
    compose,
    copy,
    def,
    divide,
    factorial,
    fib,
    filter,
    first,
    flatten,
    flow,
    head,
    isArray,
    last,
    length,
    map,
    max,
    merge,
    min,
    multiply,
    partial,
    pluck,
    quicksort,
    reduce,
    reduceRight,
    reject,
    reverse,
    reverseArgs,
    slice,
    spreadArg,
    swap,
    tail,
    undef
  }

  // default export the entire bundle (combo functions + core)
  var index = { ...core }

  return index;

})));
